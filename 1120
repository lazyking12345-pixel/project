8.10.1 question
1번
프로시저가 지역 변수·스택 매개변수를 쓸 때, 에필로그에 들어갈 문장
일반 패턴: mov esp,ebp (로컬 스택 복구) → pop ebp (이전 프레임 포인터 복구) → ret (복귀)

2번
C 함수가 32비트 int를 반환할 때 값이 저장되는 곳
32비트 환경 기준으로 EAX 레지스터이지만 64비트에서는 하위 32비트 EAX이다.

3번
STDCALL 호출 규약에서 스택 정리는 어떻게 하는가?
호출된 callee 쪽에서 ret n 처럼 리턴 명령이 인자 크기만큼 스택을 한꺼번에 정리한다.

4번
LEA가 OFFSET보다 더 강력한 이유
OFFSET은 “심볼의 주소”만 상수로 주지만, LEA는 임의의 계산(베이스+인덱스+스케일+상수)을 한 번에 계산해서 레지스터에 넣을 수 있다.

5번
C++ 예제(Section 8.2.3)에서 int 변수가 차지하는 스택 공간
32비트 환경 기준으로 int는 보통 4바이트를 사용한다.

6번
C 호출 규약이 STDCALL보다 가질 수 있는 장점
호출자(caller)가 스택을 정리하기때문에 가변 인자 함수(printf 등)를 쉽게 만들 수 있고
같은 함수를 다른 방식으로 호출해도 유연하게 스택을 조절할 수 있다

7번
PROC 지시어를 사용할 때 모든 매개변수는 한 줄에 나열해야 한다.
여러 줄로 나눠 쓸 수 있으므로 필수는 아니라서 정답이 아니다
정답: False

8번
바이트 배열 오프셋을 담은 변수를, 워드 배열 포인터를 기대하는 프로시저에 넘기면 어셈블러가 에러로 잡는다.
어셈블러는 보통 “단순 주소값”만 보고 타입 의미까지 강하게 검사하지 않는다.
정답: False

9번
참조 매개변수를 기대하는 프로시저에 즉값을 넘기면 general‑protection fault가 날 수 있다.
즉값은 메모리 주소가 아니라서, 그 값을 포인터로 사용하면 잘못된 주소 접근으로 예외(GP fault)가 발생할 수 있다.
정답: True
