4.9 question
1번
one = 8002h = 16진 기준 상위 비트가 1 → 부호 있는 16비트 값으로는 음수(-32766)
movsx는 부호 비트를 그대로 늘리므로 EDX = FFFF8002h
two = 4321h, 상위 비트 0 → 양수
movsx는 그냥 00004321h로 확장
정답: (a) EDX = FFFF8002h, (b) EDX = 00004321h

2번
AX는 EAX의 하위 16비트(FFFFh). FFFFh + 1 → 0000h, 상위 16비트는 그대로 1002h 유지된다.
그러면 나오는 결과는 EAX = 10020000h

3번
AX는 0000h → 0000h - 1 = FFFFh, 상위 16비트(3002h)는 그대로된다.
그렇기에 나오는 결과는 EAX = 3002FFFFh

4번
AX = FFFFh. neg은 0에서 빼기: 0000h - FFFFh = 0001h (2의 보수)
상위 16비트 1002h 유지 → EAX = 10020001h

5번
AL = 1 + 3 = 4 (00000100b).
Parity 플래그는 하위 8비트에서 1의 개수가 짝수면 1. 여기서는 1비트가 하나뿐 → 홀수.
결과는 Parity flag = 0 (클리어)

6번
EAX = 5 - 6 = -1 = FFFFFFFFh
최상위 비트가 1이므로 Sign flag = 1
정답: EAX = FFFFFFFFh, SF = 1

7번
AL은 signed byte로 해석하면 처음 값 -1 (FFh). 130(82h)를 더하면 FFh + 82h = 181h → 하위 8비트만 남아 81h.
81h는 signed byte로 -127이므로 여전히 signed 범위(-128~127) 안에 있다.
하지만 연산 도중 FFh(-1) + 82h(+130)는 수학적으로 129로, signed 8비트에서 표현 범위를 넘기 때문에 Overflow 플래그가 1로 설정된다.
즉, OF는 “연산이 부호 있는 범위를 넘었다”는 것만 알려 주고, 최종 결과 값(81h)이 실제로는 또 하나의 유효한 signed 값(-127)이라는 점은 구분해 주지 못한다.

8번
그냥 즉값을 64비트 레지스터에 넣는다(상위는 0으로 채움)
정답: RAX = 00000000_44445555h

9번
두 번째 mov가 앞의 값을 덮어쓴다. DWORD를 RAX에 넣으면 상위 32비트는 0
정답: RAX = 00000000_84326732h

10번
dval1 = 12 34 56 78h
WORD PTR dval1+2는 마지막 두 바이트 56 78h → AX = 5678h
마지막 mov eax,dval1이 전체를 덮어쓰므로 EAX는 dval1 값
답: EAX = 12345678h

11번
먼저 dval1 ← 12345678h
mov ax,WORD PTR dval1+2로 AX = 5678h지만, 곧 mov ax,3로 다시 0003h
mov DWORD PTR dval1,ax는 32비트에 00000003h 저장 → dval1 = 00000003h
dval 은 초기값 ? 이지만 마지막 줄에서 읽음. 코드에 dval에 대한 저장이 없어서, 의도는 아마 dval1일 것. 시험/과제라면 “EAX는 정의되지 않은 값”라고 답하는 게 맞다.

12번
양수 + 음수 연산에서 오버플로 플래그를 켤 수 있는가?
부호 있는 덧셈에서 오버플로는 “같은 부호 둘을 더해서 다른 부호가 될 때”만 생긴다. 양수와 음수는 부호가 다르므로 오버플로가 날 수 없다.
그렇기때문에 틀린 문제이다. 정답: No

13번
음수 + 음수 = 양수가 될 때 오버플로가 켜지는가?
음수 두 개를 더해 양수가 나오면 부호 범위를 넘어선 것이므로 OF = 1이 된다.
그렇기때문에 정답이다.
정답: Yes

14번
NEG 명령이 OF를 설정할 수 있는가?
2의 보수에서 최솟값(예: -128)을 neg 하면 +128이 필요한데 표현 범위를 벗어나므로 OF가 1이 된다.
그러므로 정답이다 
정답: Yes

15번
Sign 플래그와 Zero 플래그가 동시에 1이 될 수 있는가?
결과가 0이면 부호 비트도 0이므로 SF=0, ZF=1이다. 둘 다 1일 수는 없다.
정답: No

16번
각 movzx 문장이 유효한지 판단
a. movzx ax,var1
8비트 메모리(바이트)를 16비트 레지스터로 옮기는 건 허용됨
정답: 유효
b. movzx ax,var2
16비트 메모리를 16비트 레지스터 AX로 옮김, 정상
정답: 유효
c. movzx eax,var3
16비트 메모리를 32비트 레지스터로 바로 mov 하는 것은 크기가 안 맞아서 안 됨(오퍼랜드 크기 불일치)
정답: 무효
d. movzx eax,var4
16비트 데이터를 8비트 변수에 그대로 mov 할 수 없음
정답: 무효
e. movzx eax,var2
16비트 → 16비트는 zero‑extend 대상이 아님(같은 크기)
정답: 무효
f. movzx var2,al
목적지가 메모리이고 크기도 안 맞으며, movzx는 레지스터를 목적지로 써야 함
정답: 무효
g. mov ds,ax
세그먼트 레지스터 DS는 AX 같은 16비트 일반 레지스터에서 로드 가능
정답: 유효
h. mov ds,1000h
세그먼트 레지스터에 즉값을 바로 넣는 형식은 허용되지 않음(중간에 일반 레지스터 필요)
정답: 무효

17번
var1 = (-4,2,3,1) 이므로 메모리 바이트는 (FC,02,03,01)
a. mov al,var1 → AL = 첫 번째 바이트 = FCh
b. mov ah,[var1+3] → AH = 네 번째 바이트 = 01h
정답:a. AL = FCh, b. AH = 01h

18번
각 줄 실행 후 AX 값만 보면 된다.
a. AX = 1000h
b. AX = 2000h
c. AX = FFF0h
d. AX = 0004h

19번
리틀엔디언이므로 var4 = 1 = 00000001h 이고, 메모리 바이트는 01 00 00 00
a. mov edx,var4 → EDX = 00000001h
b. mov edx,var4+2 → 주소가 2바이트 뒤이므로 00 00 00 00을 32비트로 읽어 00000000h
c. mov edx,[var4+4] → 두 번째 DWORD = 00000002h
d. mov edx,var1 → 바이트 -4 = FCh를 32비트로 읽으면 000000FCh
정답: a. EDX = 00000001h
b. EDX = 00000000h
c. EDX = 00000002h
d. EDX = 000000FCh
