1.7 question
1번
8비트 이진수에서 MSB는 가장 왼쪽 비트이다.
2번
각 이진수를 2진→10진으로 바꾸면 된다. 1 2 4 8 16 32 64 ....
a = 00110101, 1 + 4 + 16 + 32 53
b = 10101100. 4 + 8 + 32 + 128 172
c = 11001100, 4 + 8 + 64 + 128 204
3번
2진 덧셈은 자리올림을 하면서 진행한다.
a. 10101111 + 11011011 = 110000010
b. 00100111 + 11111111 = 100100110
c. 01110101 + 10101100 = 100100001
4번
00001101(13) - 00000111(7) = 00000110(6)
5번
x86 계열에서 word는 16비트, doubleword는 32비트, quadword는 64비트,
double quadword는 128비트이다.
6번
정수 N을 표현하는 데 필요한 최소 비트 수는 2k−1≤N≤2k−12k−1≤N≤2k−1을 만족하는 k를 찾으면 된다.​
a. 4095는 212−1212−1 이므로 12비트.​
b. 65534는 216−2216−2 이므로 16비트.​
c. 42319는 215<42319<216215<42319<216 이므로 16비트.
7번
2진→16진은 4비트씩 끊어 각 그룹을 16진 한 자리로 바꾸면 된다.
a, 3 5 D A
b, C E A 3
c, F E D B
8번
16진→2진은 각 16진 자리를 4비트 이진수로 바꾸면 된다.
a, 0000 0001 0010 0110 1111 1001 1101 0100
b, 0110 1010 1100 1101 1111 1010 1001 0101
c, 1111 0110 1001 1011 1101 1100 0010 1010
9번
16진수를 2진→10진으로 바꾸거나, 각 자리의 가중치(16의 거듭제곱)를 이용해 계산한다.
a, 3A = 58
b, 1BF = 447
c, 1001 = 4097
10번
16진수를 부호 없는 10진수
6E = 110
4B3 = 1203
229F = 671
11번
16비트 2의 보수로 표현
a, −24: 24 = 0000 0000 0001 1000 → 반전 1111 1111 1110 0111 → +1 = 1111 1111 1110 1000 (FFE8)
b, −331: 331 = 0000 0001 0100 1011 → 반전 1111 1110 1011 0100 → +1 = 1111 1110 1011 0101 (FEB5)
12번
a, −21: 21 = 0000 0000 0001 0101 → 반전 1111 1111 1110 1010 → +1 = 1111 1111 1110 1011 (FFEB)
b, −45: 45 = 0000 0000 0010 1101 → 반전 1111 1111 1101 0010 → +1 = 1111 1111 1101 0011 (FFD3)
13번
16비트 부호 있는 16진수 → 10진
맨 앞 16진 자리가 8~F면 음수(2의 보수)
6BF9: 맨 앞 6 < 8 이므로 27641
C123: C ≥ 8 이므로 음수. 16비트에서 C123은 0xC123 = 49443, 2의 보수 값이므로 16093
14번
4CD2: 맨 앞 4 < 8 → 양수, 19666
8230: 맨 앞 8 ≥ 8 → 음수, -32208
15번
부호 있는 8비트 2의 보수 → 10진
10110101: MSB=1이므로 음수. 2의 보수 복원하면 01001011 = 75 → −75
00101100: MSB=0 → 그냥 양수 44
11110000: 음수, 복원하면 00010000 = 16 → −16
16번
10000000: 음수, 복원하면 01111111 = 127 → −128 (8비트 최소값)
11000001: 음수, 복원하면 00111111 = 63 → −63
10010110: 음수, 복원하면 01101010 = 106 → −106
17번
8비트 2의 보수로 나타내기
−5: +5는 0000 0101 → 반전 1111 1010 → +1 = 1111 1011
−42: +42는 0010 1010 → 반전 1101 0101 → +1 = 1101 0110
−16: +16은 0001 0000 → 반전 1110 1111 → +1 = 1111 0000
18번
−72: +72는 0100 1000 → 반전 1011 0111 → +1 = 1011 1000
−22: +22는 0001 0110 → 반전 1110 1001 → +1 = 1110 1010
−26: +26은 0001 1010 → 반전 1110 0101 → +1 = 1110 0110
19번
16진수 덧셈 (각 자리에서 16진수로 더함)
684 + 3FE = 0x684 + 0x3FE = 0XA82
A49 + 6BD = 0xA49 + 0x6BD = 0x1106
20번
16진수 덧셈
a, 7C4 + 3BE, 0x7C4 = 1988, 0x3BE = 958 → 합 2946 = 0xB82.
b, B69 + 7AD, 0xB69 = 2921, 0x7AD = 1965 → 합 4886 = 0x1316.
21번
ASCII 대문자 B
10진 코드: 66
16진 코드: 42
22번
ASCII 대문자 G
10진 코드: 71
16진 코드: 47
23번
129비트 부호 없는 정수의 최댓값
n비트 부호 없는 정수 범위: 0 ~ (2의 n제곱 - 1)
따라서 129비트일 때 최댓값: 2의 129제곱 - 1
24번
n비트 2의 보수 정수의 양수 범위: 0 ~ (2의 (n-1)제곱 - 1)
따라서 86비트일 때 최댓값: 2의 85제곱 - 1
25번, 26번 헷갈리는 부분이 있어서 못 풀겠음
27번
입력이 네 개인 불 함수의 진리표 행 수
입력 개수가 n개이면 가능한 조합은 2의 n제곱 개
n = 4 → 2의 4제곱 = 16행 필요
28번
4-입력 멀티플렉서에 필요한 선택 비트 수
4개의 입력 중 하나를 선택해야 하므로 경우의 수 4개
2비트면 2의 2제곱 = 4가지 표현 가능 → 선택 비트 2개면 충분
